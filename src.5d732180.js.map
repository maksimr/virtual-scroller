{"version":3,"sources":["node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","lib/scrollbar.js","lib/size-manager.js","lib/resize-observer.js","lib/virtual-scroller.js","src/index.js"],"names":["_classCallCheck","instance","Constructor","TypeError","module","exports","__esModule","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","Scrollbar","viewportElement","params","_classCallCheck2","default","scrollPosition","scrollElement","findScrollableElement","scrollListenElement","document","documentElement","window","scrollListener","horizontal","viewportSize","clientWidth","clientHeight","maxScrollSize","Math","round","calcMaxBrowserScrollSize","currentPage","prevViewportScrollPosition","currentPageOffset","runwayElement","createElement","style","width","height","scrollSize","position","visibility","overflow","updateTotalSize","totalSize","getComputedStyle","firstChild","insertBefore","appendChild","addScrollListener","scrollTo","_createClass2","value","viewportScrollTop","getViewportScrollPosition","abs","onJump","onSmoothScroll","updateScrollPosition","max","browserScrollPosition","getOffsetBetweenScrollElementAndViewport","findOffsetBetween","viewportScrollPosition","offset","arguments","scrollLeft","scrollTop","pageSize","scrollToNextPage","scrollToPrevPage","scrollOnPage","pageNumber","floor","setCurrentPage","prevPage","viewportScrollTo","overlapSize","onScroll","bind","addEventListener","removeEventListener","pageCount","ceil","prevOverlapSize","scrollPage","removeChild","removeScrollListener","bigNumber","div","left","top","body","size","getBoundingClientRect","parseInt","element","parentNode","undefined","boundingClientRect","boundingClientRectDocument","offsetTop","offsetLeft","DEFAULT_HEIGHT_ESTIMATE_PX","SizeManager","reset","sizes","has","oldSize","get","measuredCount","newSize","offsetWidth","offsetHeight","totalMeasuredSize","set","getAverageSize","delete","WeakMap","addResizeListener","listener","prevElementHeight","prevElementWidth","options","passive","capture","resizeObserver","createResizeObserver","queueMicrotask","setupTriggers","event","currentTarget","growObserver","shrinkObserver","lastChild","growObserverOffsetHeight","growObserverOffsetWidth","growObserverScrollHeight","scrollHeight","growObserverScrollWidth","scrollWidth","shrinkObserverScrollHeight","shrinkObserverScrollWidth","setupScrollPosition","setAttribute","cloneNode","callback","Promise","resolve","then","catch","e","setTimeout","_scrollbar","require","_sizeManager","_resizeObserver","_interopRequireDefault","VirtualScroller","_this","itemCount","Boolean","onRemoveItem","itemBuilder","bufferSize","hasOwnProperty","sizeManager","builder","expectedItemSize","itemSize","expectedTotalSize","rendered","range","start","end","prevScrollPosition","throttleTime","scrollbar","scheduleSync","_this2","clearTimeout","scrollThrottlingId","_this3","syncId","requestAnimationFrame","sync","render","createRangeForCurrentPosition","startOffset","endOffset","getHopefulSize","averageItemSize","startElement","endElement","maxIndex","min","_this4","firstVisibleItemIndex","findFirstVisibleItemIndex","addedElements","documentFragment","createDocumentFragment","newElement","push","forEach","remove","measure","renderedElement","positionElement","scrollCorrection","offsetMismatch","maxScrollTop","checkRange","_this5","index","keys","find","Number","item","String","calc","destroy","cancelAnimationFrame","_virtualScroller","main","JSON","parse","decodeURIComponent","location","search","slice","count","appElement","getElementById","assign","it","padding","innerHTML","concat"],"mappings":"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","file":"src.5d732180.js","sourceRoot":"..","sourcesContent":["function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nmodule.exports = _classCallCheck, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nmodule.exports = _createClass, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","export class Scrollbar {\n  /**\n   * @typedef {{totalSize: number, scrollListener: function(...[*]=):void, horizontal?: boolean, scrollPosition?: number}} ScrollbarParams\n   */\n  /**\n   * @param {HTMLElement} viewportElement\n   * @param {ScrollbarParams} params\n   * @return {Scrollbar}\n   */\n  static builder(viewportElement, params) {\n    return new Scrollbar(viewportElement, params);\n  }\n\n  /**\n   * @param {HTMLElement} viewportElement\n   * @param {ScrollbarParams} params\n   */\n  constructor(viewportElement, params) {\n    /**\n     * @public\n     * @type number\n     */\n    this.scrollPosition = 0;\n\n    /**\n     * @private\n     * @type HTMLElement\n     */\n    this.viewportElement = viewportElement;\n    /**\n     * @private\n     * @type HTMLElement\n     */\n    this.scrollElement = findScrollableElement(this.viewportElement);\n    /**\n     * @private\n     * @type {(Element|Window)}\n     */\n    this.scrollListenElement = this.scrollElement === document.documentElement ? window : this.scrollElement;\n    /**\n     * @private\n     * @type function():any\n     */\n    this.scrollListener = params.scrollListener;\n    /**\n     * @private\n     * @type boolean\n     */\n    this.horizontal = params.horizontal;\n    /**\n     * @public\n     * @type number\n     */\n    this.viewportSize = this.horizontal ? this.scrollElement.clientWidth : this.scrollElement.clientHeight;\n    /**\n     * Divide on 2 because it's too performance consuming and complicated handle case when offset between\n     * scroll node and viewport is changed dynamically we should also change max browser scroll size too.\n     * And Chrome works significantly slower and janky when you have a scrollbar with maximal height\n     * @private\n     * @type {number}\n     */\n    this.maxScrollSize = Math.round(calcMaxBrowserScrollSize(this.horizontal) / 2);\n\n    /**\n     * @private\n     * @type number\n     */\n    this.currentPage = 0;\n    /**\n     * @private\n     * @type number\n     */\n    this.prevViewportScrollPosition = 0;\n\n    /**\n     * @private\n     * @type number\n     */\n    this.currentPageOffset = 0;\n\n    /**\n     * @private\n     * @type HTMLElement\n     */\n    this.runwayElement = document.createElement('div');\n    this.runwayElement.style.width = this.runwayElement.style.height = '1px';\n    this.runwayElement.style[this.horizontal ? 'width' : 'height'] = this.scrollSize + 'px';\n    this.runwayElement.style.position = 'relative';\n    this.runwayElement.style.visibility = 'hidden';\n    this.runwayElement.style.overflow = 'hidden';\n\n    this.updateTotalSize(params.totalSize || 0);\n\n    if (window.getComputedStyle(this.viewportElement).position === 'static') {\n      this.viewportElement.style.position = 'relative';\n    }\n\n    if (this.viewportElement.firstChild) {\n      this.viewportElement.insertBefore(this.runwayElement, this.viewportElement.firstChild);\n    } else {\n      this.viewportElement.appendChild(this.runwayElement);\n    }\n\n    this.addScrollListener();\n\n    if (params.scrollPosition) {\n      this.scrollTo(params.scrollPosition);\n    }\n  }\n\n  /**\n   * @private\n   */\n  onScroll() {\n    const viewportScrollTop = this.getViewportScrollPosition();\n    if (Math.abs(viewportScrollTop - this.prevViewportScrollPosition) > this.viewportSize) {\n      this.onJump();\n    } else {\n      this.onSmoothScroll();\n    }\n\n    this.prevViewportScrollPosition = this.getViewportScrollPosition();\n    this.updateScrollPosition(this.getViewportScrollPosition() + this.currentPageOffset);\n    this.scrollListener();\n  }\n\n  /**\n   * @private\n   * @param {number} scrollPosition\n   */\n  updateScrollPosition(scrollPosition) {\n    this.scrollPosition = Math.max(scrollPosition, 0);\n  }\n\n  /**\n   * @private\n   * @return {number}\n   */\n  getViewportScrollPosition() {\n    return Math.max(this.browserScrollPosition() - this.getOffsetBetweenScrollElementAndViewport(), 0);\n  }\n\n  /**\n   * @private\n   * @return {number}\n   */\n  getOffsetBetweenScrollElementAndViewport() {\n    return this.scrollElement !== this.viewportElement ? findOffsetBetween(this.viewportElement, this.scrollElement, this.horizontal) : 0;\n  }\n\n  /**\n   * @private\n   * @param {number} viewportScrollPosition\n   * @return {number}\n   */\n  viewportScrollTo(viewportScrollPosition) {\n    const offset = this.getOffsetBetweenScrollElementAndViewport();\n    return this.browserScrollPosition(viewportScrollPosition + offset);\n  }\n\n  /**\n   * @param {number=} scrollPosition\n   * @return {number}\n   */\n  browserScrollPosition(scrollPosition) {\n    if (!arguments.length) {\n      return this.horizontal ?\n        this.scrollElement.scrollLeft :\n        this.scrollElement.scrollTop;\n    }\n\n    if (this.horizontal) {\n      this.scrollElement.scrollLeft = scrollPosition;\n    } else {\n      this.scrollElement.scrollTop = scrollPosition;\n    }\n  }\n\n  /**\n   * @private\n   */\n  onSmoothScroll() {\n    const scrollPosition = this.getViewportScrollPosition();\n\n    if (scrollPosition + this.currentPageOffset > (this.currentPage + 1) * this.pageSize) {\n      this.scrollToNextPage();\n    } else if (this.currentPage && (scrollPosition + this.currentPageOffset) < this.currentPage * this.pageSize) {\n      this.scrollToPrevPage();\n    }\n  }\n\n  /**\n   * @private\n   */\n  scrollToNextPage() {\n    this.scrollOnPage(this.currentPage + 1);\n  }\n\n  /**\n   * @private\n   */\n  scrollToPrevPage() {\n    this.scrollOnPage(this.currentPage - 1);\n  }\n\n  /**\n   * @private\n   */\n  onJump() {\n    const viewportScrollPosition = this.getViewportScrollPosition();\n    // convert actual pixels to total pixels\n    const scrollPosition = viewportScrollPosition * ((this.totalSize - this.viewportSize) / (this.scrollSize - this.viewportSize));\n    const pageNumber = Math.floor(scrollPosition / this.pageSize);\n    this.setCurrentPage(pageNumber);\n  }\n\n  /**\n   * @private\n   * @param {number} currentPage\n   */\n  scrollOnPage(currentPage) {\n    const prevPage = this.currentPage;\n    if (prevPage < currentPage) {\n      this.viewportScrollTo(this.getViewportScrollPosition() - this.overlapSize);\n    } else if (prevPage > currentPage) {\n      this.viewportScrollTo(this.getViewportScrollPosition() + this.overlapSize);\n    }\n    this.setCurrentPage(currentPage);\n  }\n\n  /**\n   * @private\n   * @param {number} currentPage\n   */\n  setCurrentPage(currentPage) {\n    if (currentPage !== this.currentPage) {\n      this.currentPage = Math.max(currentPage, 0);\n      this.currentPageOffset = Math.round(this.currentPage * this.overlapSize);\n    }\n  }\n\n  /**\n   * @private\n   */\n  addScrollListener() {\n    /**\n     * @private\n     */\n    this.onScroll = this.onScroll.bind(this);\n    this.scrollListenElement.addEventListener('scroll', this.onScroll);\n  }\n\n  /**\n   * @private\n   */\n  removeScrollListener() {\n    this.scrollListenElement.removeEventListener('scroll', this.onScroll);\n  }\n\n  /**\n   * @public\n   * @param {number} totalSize\n   */\n  updateTotalSize(totalSize) {\n    if (this.totalSize === totalSize) {\n      return;\n    }\n\n    /**\n     * @public\n     * @type {number}\n     */\n    this.totalSize = totalSize;\n    /**\n     * @private\n     * @type {number}\n     */\n    this.scrollSize = this.maxScrollSize > this.totalSize ? this.totalSize : this.maxScrollSize;\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pageSize = Math.floor(this.maxScrollSize / 100);\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pageCount = Math.ceil(this.totalSize / this.pageSize);\n\n    const prevOverlapSize = this.overlapSize;\n    /**\n     * @private\n     * @type {number}\n     */\n    this.overlapSize = this.totalSize > this.maxScrollSize ? (this.totalSize - this.maxScrollSize) / (this.pageCount - 1) : 1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.currentPageOffset = Math.round(this.currentPage * this.overlapSize);\n\n    this.runwayElement.style[this.horizontal ? 'width' : 'height'] = this.scrollSize + 'px';\n\n    if (this.scrollPosition > (this.totalSize - this.viewportSize)) {\n      this.updateScrollPosition(this.totalSize - this.viewportSize);\n    }\n\n    // If we on the last page and user has updated totalSize\n    // we should check overlap size and if new overlap size is\n    // bigger than previous we should remove this difference by\n    // jumping back on this size otherwise it can lead to the problem\n    // that we have reach the bottom and can not scroll future but\n    // totalSize say that we should have scroll possibility\n    if (\n      this.currentPage === this.pageCount - 1 &&\n      prevOverlapSize &&\n      prevOverlapSize < this.overlapSize) {\n      this.prevViewportScrollPosition = this.viewportScrollTo(this.prevViewportScrollPosition - this.currentPage * (this.overlapSize - prevOverlapSize));\n    }\n  }\n\n  // noinspection JSUnusedGlobalSymbols\n  /**\n   * @public\n   * @param {number} scrollPosition\n   */\n  scrollTo(scrollPosition) {\n    if (this.scrollPosition !== scrollPosition) {\n      this.updateScrollPosition(scrollPosition);\n      const scrollPage = Math.floor(scrollPosition / this.pageSize);\n      this.setCurrentPage(scrollPage);\n      this.prevViewportScrollPosition = this.viewportScrollTo(scrollPosition - this.currentPageOffset);\n    }\n  }\n\n  // noinspection JSUnusedGlobalSymbols\n  /**\n   * @public\n   * Calculate actual position on viewport for passed scrollbar position\n   * @param {number} position\n   * @return {number}\n   */\n  calc(position) {\n    return position - this.currentPageOffset;\n  }\n\n  // noinspection JSUnusedGlobalSymbols\n  /**\n   * @public\n   */\n  destroy() {\n    this.viewportElement.removeChild(this.runwayElement);\n    this.removeScrollListener();\n  }\n}\n\n/**\n * @param {boolean=} horizontal\n * @return {number}\n */\nexport function calcMaxBrowserScrollSize(horizontal) {\n  const bigNumber = '9999999999999999px';\n  const div = document.createElement('div');\n  const style = div.style;\n  style.position = 'absolute';\n  style.left = bigNumber;\n  style.top = bigNumber;\n  document.body.appendChild(div);\n\n  const size = div.getBoundingClientRect()[horizontal ? 'left' : 'top'] || parseInt(bigNumber);\n  document.body.removeChild(div);\n  return Math.abs(size);\n}\n\n/**\n * @param {HTMLElement} element\n * @return {HTMLElement}\n */\nexport function findScrollableElement(element) {\n  while (element.parentNode && element.parentNode !== document) {\n    const overflow = window.getComputedStyle(element).overflow;\n    if (overflow === 'visible' || overflow === '') {\n      /**\n       * @type {Element}\n       */\n      // @ts-ignore\n      element = element.parentNode;\n      continue;\n    }\n    break;\n  }\n  return element;\n}\n\n/**\n * @param {(HTMLElement)} element\n * @param {(HTMLElement)} scrollElement\n * @param {boolean?} horizontal\n * @return {number}\n */\nfunction findOffsetBetween(element, scrollElement, horizontal = false) {\n  // If scrollElement is documentElement we can\n  // calculate it by getBoundingClientRect and dont traverse all parents\n  if (scrollElement === document.documentElement) {\n    const boundingClientRect = element.getBoundingClientRect();\n    const boundingClientRectDocument = scrollElement.getBoundingClientRect();\n    return horizontal ?\n      boundingClientRect.left - boundingClientRectDocument.left :\n      boundingClientRect.top - boundingClientRectDocument.top;\n  }\n\n  let offset = 0;\n  while (element && element.parentNode && element !== scrollElement) {\n    // noinspection JSValidateTypes\n    /**\n     * @type {HTMLElement}\n     */\n      // @ts-ignore\n    const parentNode = element.parentNode;\n    const offsetTop = horizontal ? element.offsetLeft : element.offsetTop;\n    offset = (window.getComputedStyle(parentNode).position !== 'static') ?\n      offset + offsetTop :\n      offset + (offsetTop - (horizontal ? parentNode.offsetLeft : parentNode.offsetTop));\n    element = parentNode;\n  }\n  return offset;\n}","const DEFAULT_HEIGHT_ESTIMATE_PX = 50;\n\nexport class SizeManager {\n  /**\n   * @param {boolean=} horizontal\n   * @returns {SizeManager}\n   */\n  static builder(horizontal = false) {\n    return new SizeManager(horizontal);\n  }\n\n  /**\n   * @param {boolean} horizontal\n   */\n  constructor(horizontal) {\n    this.horizontal = horizontal;\n    this.reset();\n  }\n\n  /**\n   * @param {!HTMLElement} element The element to measure.\n   * @return {boolean}\n   */\n  has(element) {\n    return this.sizes.has(element);\n  }\n\n  /**\n   * Measures and stores |element|'s size. If |element| was measured\n   * previously, this updates everything to use the new current size.\n   * @param {!HTMLElement} element The element to measure.\n   */\n  measure(element) {\n    let oldSize = this.sizes.get(element);\n    if (oldSize === undefined) {\n      oldSize = 0;\n      this.measuredCount++;\n    }\n    const newSize = this.horizontal ? element.offsetWidth : element.offsetHeight;\n    this.totalMeasuredSize += newSize - oldSize;\n    this.sizes.set(element, newSize);\n  }\n\n  /**\n   * Returns a size for |element|, either the last stored size or an\n   * estimate based on all other previously measured elements or a\n   * default.\n   * @param {!HTMLElement} element The element to produce a size for.\n   * @return {number}\n   */\n  getHopefulSize(element) {\n    const size = this.sizes.get(element);\n    return size === undefined ? this.getAverageSize() : size;\n  }\n\n  getAverageSize() {\n    return this.measuredCount > 0 ?\n      this.totalMeasuredSize / this.measuredCount :\n      DEFAULT_HEIGHT_ESTIMATE_PX;\n  }\n\n  /**\n   * Removes all data related to |element| from the manager.\n   * @param {!HTMLElement} element The element to remove.\n   */\n  remove(element) {\n    const oldSize = this.sizes.get(element);\n    if (oldSize === undefined) {\n      return;\n    }\n    this.totalMeasuredSize -= oldSize;\n    this.measuredCount--;\n    this.sizes.delete(element);\n  }\n\n  reset() {\n    this.sizes = new WeakMap();\n    this.totalMeasuredSize = 0;\n    this.measuredCount = 0;\n  }\n}\n","/**\n * @param {HTMLElement} element\n * @param {function} listener\n * @return {function(...[*]=)} Remove listener function\n */\nexport function addResizeListener(element, listener) {\n  const options = {passive: true, capture: true};\n  const resizeObserver = createResizeObserver();\n  let prevElementHeight;\n  let prevElementWidth;\n\n  element.appendChild(resizeObserver);\n  resizeObserver.addEventListener('scroll', onScroll, options);\n\n  // Postpone calculation to avoid \"Layout Thrashing\"\n  queueMicrotask(() => setupTriggers(resizeObserver));\n\n  return () => {\n    resizeObserver.removeEventListener('scroll', onScroll, options);\n    element.removeChild(resizeObserver);\n  };\n\n  function onScroll(event) {\n    if (\n      prevElementHeight !== element.offsetHeight ||\n      prevElementWidth !== element.offsetWidth) {\n      prevElementHeight = element.offsetHeight;\n      prevElementWidth = element.offsetWidth;\n      const resizeObserver = event.currentTarget;\n      setupTriggers(resizeObserver);\n      listener(element);\n    }\n  }\n}\n\n/**\n * @param {Node} resizeObserver\n */\nfunction setupTriggers(resizeObserver) {\n  /**\n   * @type {HTMLElement}\n   */\n    // @ts-ignore\n  const growObserver = resizeObserver.firstChild;\n  /**\n   * @type {HTMLElement}\n   */\n    // @ts-ignore\n  const shrinkObserver = resizeObserver.lastChild;\n  const growObserverOffsetHeight = growObserver.offsetHeight;\n  const growObserverOffsetWidth = growObserver.offsetWidth;\n  const growObserverScrollHeight = growObserver.scrollHeight;\n  const growObserverScrollWidth = growObserver.scrollWidth;\n  const shrinkObserverScrollHeight = shrinkObserver.scrollHeight;\n  const shrinkObserverScrollWidth = shrinkObserver.scrollWidth;\n\n  queueMicrotask(() => {\n    /**\n     * @type {HTMLElement}\n     */\n      // @ts-ignore\n    const firstChild = growObserver.firstChild;\n    firstChild.style.height = growObserverOffsetHeight + 1 + 'px';\n    firstChild.style.width = growObserverOffsetWidth + 1 + 'px';\n    queueMicrotask(setupScrollPosition);\n  });\n\n  function setupScrollPosition() {\n    growObserver.scrollTop = growObserverScrollHeight;\n    growObserver.scrollLeft = growObserverScrollWidth;\n    shrinkObserver.scrollTop = shrinkObserverScrollHeight;\n    shrinkObserver.scrollLeft = shrinkObserverScrollWidth;\n  }\n}\n\n/**\n * @return {Node}\n */\nfunction createResizeObserver() {\n  // @ts-ignore\n  if (!createResizeObserver.resizeObserver) {\n    const resizeObserver = document.createElement('div');\n    const growObserver = document.createElement('div');\n    const shrinkObserver = document.createElement('div');\n    const style = 'position: absolute; height: 100%; width: 100%; top:0; left:0; opacity: 0; visibility: hidden; z-index: -1; overflow: hidden; contain: paint size style; pointer-events: none;';\n\n    resizeObserver.setAttribute('style', style);\n    growObserver.setAttribute('style', style);\n    shrinkObserver.setAttribute('style', style);\n    growObserver.style.overflow = shrinkObserver.style.overflow = 'auto';\n    growObserver.appendChild(document.createElement('div'));\n    shrinkObserver.appendChild(document.createElement('div'));\n    resizeObserver.appendChild(growObserver);\n    resizeObserver.appendChild(shrinkObserver);\n    /**\n     * @type {HTMLElement}\n     */\n      // @ts-ignore\n    const firstChild = shrinkObserver.firstChild;\n    firstChild.style.height = '200%';\n    firstChild.style.width = '200%';\n\n    // @ts-ignore\n    createResizeObserver.resizeObserver = resizeObserver;\n  }\n\n  // @ts-ignore\n  return createResizeObserver.resizeObserver.cloneNode(true);\n}\n\n/**\n * @param {function():any} callback\n * @return {Promise<void | number>|void}\n */\nfunction queueMicrotask(callback) {\n  if (typeof window.queueMicrotask !== 'function') {\n    if (window.Promise) {\n      return window.Promise.resolve()\n        .then(callback)\n        .catch(e => setTimeout(() => { throw e; }));\n    }\n    return callback();\n  }\n  return window.queueMicrotask(callback);\n}\n","import { Scrollbar } from './scrollbar';\nimport { SizeManager } from './size-manager';\nimport { addResizeListener } from './resize-observer';\n\nexport class VirtualScroller {\n  /**\n   * @typedef {{itemCount: number, itemBuilder: function(number):Element, onRemoveItem?: function(number):void, itemSize?: number, bufferSize?: number, scrollPosition?: number, horizontal?: boolean}} VirtualScrollerParams\n   */\n  /**\n   * @param {HTMLElement} element\n   * @param {VirtualScrollerParams} params\n   * @returns {VirtualScroller}\n   */\n  static builder(element, params) {\n    return new VirtualScroller(element, params);\n  }\n\n  /**\n   * @param {HTMLElement} viewportElement\n   * @param {VirtualScrollerParams} params\n   */\n  constructor(viewportElement, params) {\n    /**\n     * @private\n     * @type {HTMLElement}\n     */\n    this.viewportElement = viewportElement;\n    /**\n     * @private\n     * @type {number}\n     */\n    this.itemCount = params.itemCount;\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.horizontal = Boolean(params.horizontal);\n    /**\n     * @private\n     * @type {function(number):void}\n     */\n    this.onRemoveItem = params.onRemoveItem;\n    /**\n     * @private\n     * @type {function(number):Element}\n     */\n    this.itemBuilder = params.itemBuilder;\n    /**\n     * @private\n     * @type {number}\n     */\n    this.bufferSize = params.hasOwnProperty('bufferSize') ? params.bufferSize : 1;\n    /**\n     * @private\n     * @type {SizeManager}\n     */\n    this.sizeManager = SizeManager.builder(this.horizontal);\n    /**\n     * @private\n     * @type {number}\n     */\n    this.expectedItemSize = params.itemSize || this.sizeManager.getAverageSize();\n    /**\n     * @private\n     * @type {number}\n     */\n    this.expectedTotalSize = this.itemCount * this.expectedItemSize;\n    /**\n     * @private\n     * @type {{}}\n     */\n    this.rendered = {};\n    /**\n     * @private\n     * @type {{start: number, end: number}}\n     */\n    this.range = {start: 0, end: 0};\n    /**\n     * @private\n     * @type {number}\n     */\n    this.prevScrollPosition = params.scrollPosition || 0;\n    /**\n     * @private\n     * @type {number}\n     */\n    this.throttleTime = 50;\n\n    /**\n     * @private\n     * @type {Scrollbar}\n     */\n    this.scrollbar = Scrollbar.builder(this.viewportElement, {\n      horizontal: this.horizontal,\n      scrollPosition: this.prevScrollPosition,\n      totalSize: this.expectedTotalSize,\n      scrollListener: () => this.onScroll()\n    });\n    this.scheduleSync();\n  }\n\n  /**\n   * @private\n   */\n  onScroll() {\n    const scrollPosition = this.scrollPosition();\n    window.clearTimeout(this.scrollThrottlingId);\n    if (Math.abs(scrollPosition - this.prevScrollPosition) > this.scrollbar.viewportSize) {\n      // Throttle rendering and layout if user scroll too fast to improve scroll performance\n      // We can stuck with this case when use scrollbar holder to change position\n      this.scrollThrottlingId = setTimeout(() => {\n        this.scheduleSync();\n      }, this.throttleTime);\n    } else {\n      this.scheduleSync();\n    }\n    this.prevScrollPosition = scrollPosition;\n  }\n\n  /**\n   * @private\n   */\n  scheduleSync() {\n    this.syncId = this.syncId || window.requestAnimationFrame(() => {\n      this.syncId = null;\n      this.sync();\n    });\n  }\n\n  /**\n   * @private\n   */\n  sync() {\n    this.render(this.createRangeForCurrentPosition());\n  }\n\n  /**\n   * @private\n   * @returns {{start: number, end: number}}\n   */\n  createRangeForCurrentPosition() {\n    const scrollPosition = this.scrollPosition();\n    const viewportSize = this.scrollbar.viewportSize;\n    const bufferSize = this.bufferSize * viewportSize;\n    const startOffset = Math.max(scrollPosition - bufferSize, 0);\n    const endOffset = scrollPosition + viewportSize + bufferSize;\n\n    let start = Math.floor(startOffset / this.expectedItemSize);\n    for (let i = this.range.start; i <= this.range.end; i++) {\n      if (\n        this.rendered[i] &&\n        this.rendered[i].offset + this.sizeManager.getHopefulSize(this.rendered[i]) > startOffset &&\n        this.rendered[i].offset < endOffset) {\n        start = i;\n        break;\n      }\n    }\n\n    let end = Math.ceil(endOffset / this.expectedItemSize) - 1;\n    for (let i = this.range.end; i >= this.range.start; i--) {\n      if (\n        this.rendered[i] &&\n        this.rendered[i].offset < endOffset &&\n        this.rendered[i].offset >= startOffset) {\n        end = i;\n        break;\n      }\n    }\n\n    // Use average item size to more precisely calculate how many items we should render\n    // if expected item size failed and we have rendered items\n    const averageItemSize = this.sizeManager.getAverageSize();\n    const startElement = this.rendered[start];\n    if (startElement && startElement.offset > startOffset) {\n      start = start - Math.ceil((startElement.offset - startOffset) / averageItemSize);\n    }\n\n    const endElement = this.rendered[end];\n    if (endElement && (endElement.offset + this.sizeManager.getHopefulSize(endElement)) < endOffset) {\n      end = end + Math.ceil((endOffset - (endElement.offset + this.sizeManager.getHopefulSize(endElement))) / averageItemSize);\n    }\n\n    const maxIndex = this.itemCount - 1;\n    return {\n      start: Math.min(Math.max(start, 0), maxIndex),\n      end: Math.max(Math.min(end, maxIndex), 0)\n    };\n  }\n\n  /**\n   * @private\n   * @param {{start: number, end: number}} range\n   */\n  render(range) {\n    const firstVisibleItemIndex = this.findFirstVisibleItemIndex();\n    const addedElements = [];\n    let documentFragment = document.createDocumentFragment();\n    for (let i = range.start; i <= range.end; i++) {\n      // Render elements so that preserving correct position in DOM tree\n      // so elements with less index should go in the DOM first\n      if (!this.rendered[i]) {\n        const newElement = this.rendered[i] = this.createElement(i);\n        addedElements.push(newElement);\n        documentFragment.appendChild(newElement);\n      } else if (documentFragment.firstChild) {\n        this.viewportElement.insertBefore(documentFragment, this.rendered[i]);\n        documentFragment = document.createDocumentFragment();\n      }\n    }\n    this.viewportElement.appendChild(documentFragment);\n\n    addedElements.forEach((element) => {\n      addResizeListener(element, () => {\n        this.sizeManager.remove(element);\n        this.scheduleSync();\n      });\n    });\n\n    // Remove elements which out of the range\n    for (let i = this.range.start; i <= this.range.end; i++) {\n      if ((i < range.start || i > range.end) && this.rendered[i]) {\n        this.onRemoveItem && this.onRemoveItem(i);\n        this.sizeManager.remove(this.rendered[i]);\n        this.viewportElement.removeChild(this.rendered[i]);\n        delete this.rendered[i];\n      }\n    }\n\n    // Measure rendered elements sizes\n    for (let i = range.start; i <= range.end; i++) {\n      if (!this.sizeManager.has(this.rendered[i])) {\n        this.sizeManager.measure(this.rendered[i]);\n      }\n    }\n\n    // Layout elements\n    // If we already have rendered elements we should try to position new\n    // elements or re-layout previous after resize with offset related to previously rendered elements\n    // this allows us to cover most popular case when user scroll from top to bottom and\n    // back. But if user would start from some middle point we can end with some jumping\n    // when reach the point where offset is negative\n    if (this.rendered[firstVisibleItemIndex] && range.start < firstVisibleItemIndex) {\n      let offset = this.rendered[firstVisibleItemIndex].offset;\n      for (let i = (firstVisibleItemIndex - 1); i >= range.start; i--) {\n        const renderedElement = this.rendered[i];\n        offset = offset - this.sizeManager.getHopefulSize(renderedElement);\n        this.positionElement(renderedElement, Math.max(offset, 0));\n      }\n    }\n\n    // If we reach the first element and its offset bigger than 0\n    // we should reset offset and correct scroll position\n    // We can stuck with this case when user had narrow viewport\n    // then scroll down so that we have removed this first element\n    // and then make viewport bigger so because we don't correct\n    // position on resize we should correct it here\n    if (range.start === 0 && this.rendered[0].offset > 0) {\n      this.rendered[0].offset = 0;\n    }\n\n    // If start element already positioned we should start from\n    // this point otherwise calculate estimated offset\n    let scrollCorrection = 0;\n    let startElement = this.rendered[range.start];\n    let offset = startElement && startElement.offset ? startElement.offset : range.start * this.expectedItemSize;\n    for (let i = range.start; i <= range.end; i++) {\n      const renderedElement = this.rendered[i];\n      if (i === firstVisibleItemIndex) {\n        scrollCorrection = offset - renderedElement.offset;\n      }\n      this.positionElement(renderedElement, offset);\n      offset += this.sizeManager.getHopefulSize(renderedElement);\n    }\n\n    if (scrollCorrection) {\n      this.scrollTo(this.scrollPosition() + scrollCorrection);\n    }\n\n    // Adjust scrollbar size\n    const offsetMismatch = offset - (range.end * this.expectedItemSize);\n    const maxScrollTop = this.scrollbar.totalSize - this.scrollbar.viewportSize;\n    const maxIndex = this.itemCount - 1;\n    if (this.scrollPosition() >= maxScrollTop &&\n      (offset > this.scrollbar.totalSize || range.end < maxIndex)) {\n      // Increase scroll height if we reach end but we still have items which\n      // should be rendered\n      this.scrollbar.updateTotalSize(this.expectedTotalSize + offsetMismatch);\n    } else if (range.end === maxIndex) {\n      // If this is the last element we should correct scroll height\n      // because we can render more space then we need\n      this.scrollbar.updateTotalSize(offset);\n    }\n\n    this.range = range;\n\n    const checkRange = this.createRangeForCurrentPosition();\n    if (checkRange.start !== range.start || checkRange.end !== range.end) {\n      this.scheduleSync();\n    }\n  }\n\n  /**\n   * @private\n   * @return {number} Returns first visible item index or -1 if we can not find first visible item\n   */\n  findFirstVisibleItemIndex() {\n    const scrollPosition = this.scrollPosition();\n    const index = Object.keys(this.rendered).find((i) => {\n      const renderedElement = this.rendered[i];\n      return renderedElement.offset <= scrollPosition && renderedElement.offset + this.sizeManager.getHopefulSize(renderedElement) > scrollPosition;\n    });\n    return index ? Number(index) : -1;\n  }\n\n  /**\n   * @private\n   * @param {number} i Element index\n   * @returns {HTMLElement}\n   */\n  createElement(i) {\n    const item = document.createElement('div');\n    item.setAttribute('index', String(i));\n    item.style.position = 'absolute';\n    item.style[this.horizontal ? 'height' : 'width'] = '100%';\n    item.appendChild(this.itemBuilder(i));\n    return item;\n  }\n\n  /**\n   * @private\n   * @param {HTMLElement} renderedElement\n   * @param {number} offset\n   */\n  positionElement(renderedElement, offset) {\n    renderedElement.style[this.horizontal ? 'left' : 'top'] = this.scrollbar.calc(offset) + 'px';\n    // @ts-ignore\n    renderedElement.offset = offset;\n  }\n\n  /**\n   * @public\n   * @return {number}\n   */\n  scrollPosition() {\n    return this.scrollbar.scrollPosition;\n  }\n\n  /**\n   * @public\n   * @param {number} position\n   */\n  scrollTo(position) {\n    this.scrollbar.scrollTo(position);\n  }\n\n  /**\n   * @public\n   */\n  destroy() {\n    this.scrollbar.destroy();\n    this.sizeManager = null;\n    this.rendered = null;\n    window.cancelAnimationFrame(this.syncId);\n    window.clearTimeout(this.scrollThrottlingId);\n    this.syncId = null;\n    this.scrollThrottlingId = null;\n  }\n\n  /**\n   * @public\n   * @param {number} value\n   */\n  updateItemCount(value) {\n    if (this.itemCount !== value) {\n      this.itemCount = value;\n      this.expectedTotalSize = this.itemCount * this.expectedItemSize;\n      this.scrollbar.updateTotalSize(this.expectedTotalSize);\n      this.scheduleSync();\n    }\n  }\n}\n","import { VirtualScroller } from '../lib/virtual-scroller';\n\nfunction main() {\n  const params = JSON.parse(decodeURIComponent(window.location.search.slice(1)) || '{}');\n  const count = params.itemCount || 3000000;\n  const appElement = document.getElementById('app');\n\n  if (!params.window) {\n    appElement.style.height = '80vh';\n    appElement.style.overflow = 'auto';\n  }\n\n  VirtualScroller.builder(appElement, Object.assign({\n    itemCount: count,\n    itemBuilder(it) {\n      const item = document.createElement('div');\n      item.style.padding = '8px';\n      if (params.horizontal) {\n        item.style.width = 300 + 'px';\n      }\n      item.innerHTML = it % 2 ?\n        `<b>${it + 1}</b>/${count} - Lorem Ipsum is simply dummy text` :\n        `<b>${it + 1}</b>/${count} - Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book`;\n      return item;\n    }\n  }, params));\n}\n\nmain();\n"]}