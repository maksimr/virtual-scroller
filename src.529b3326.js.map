{"version":3,"sources":["node_modules/@babel/runtime/helpers/classCallCheck.js","node_modules/@babel/runtime/helpers/createClass.js","lib/scrollbar.js","lib/size-manager.js","lib/resize-observer.js","lib/virtual-scroller.js","src/index.js"],"names":["Scrollbar","viewportElement","params","scrollTop","scrollElement","findScrollableElement","scrollListenElement","document","documentElement","window","scrollListener","horizontal","viewportSize","clientWidth","clientHeight","maxScrollSize","Math","round","calcMaxBrowserScrollSize","currentPage","prevViewportScrollTop","currentPageOffset","runwayElement","createElement","style","scrollSize","position","visibility","overflow","width","updateTotalSize","totalSize","getComputedStyle","firstChild","insertBefore","appendChild","addScrollListener","scrollTo","viewportScrollTop","getViewportScrollTop","abs","onJump","onSmoothScroll","updateScrollTop","max","getOffsetBetweenScrollElementAndViewport","findOffsetBetween","offset","pageSize","scrollToNextPage","scrollToPrevPage","scrollOnPage","pageNumber","floor","setCurrentPage","prevPage","viewportScrollTo","overlapSize","onScroll","bind","addEventListener","removeEventListener","pageCount","ceil","prevOverlapSize","scrollPosition","scrollPage","removeChild","removeScrollListener","bigNumber","div","left","top","body","size","getBoundingClientRect","parseInt","element","parentNode","offsetTop","DEFAULT_HEIGHT_ESTIMATE_PX","SizeManager","reset","sizes","has","oldSize","get","undefined","measuredCount","newSize","offsetHeight","totalMeasuredSize","set","getAverageSize","delete","WeakMap","addResizeListener","listener","options","passive","capture","resizeObserver","createResizeObserver","queueMicrotask","setupTriggers","event","prevElementHeight","prevElementWidth","offsetWidth","currentTarget","growObserver","shrinkObserver","lastChild","growObserverOffsetHeight","growObserverOffsetWidth","growObserverScrollHeight","scrollHeight","growObserverScrollWidth","scrollWidth","shrinkObserverScrollHeight","shrinkObserverScrollWidth","setupScrollPosition","scrollLeft","height","setAttribute","cloneNode","callback","Promise","resolve","then","catch","e","setTimeout","VirtualScroller","itemCount","onRemoveItem","itemBuilder","bufferSize","hasOwnProperty","sizeManager","builder","expectedItemSize","itemSize","expectedTotalSize","rendered","range","start","end","prevScrollTop","throttleTime","scrollbar","scheduleSync","clearTimeout","scrollThrottlingId","syncId","requestAnimationFrame","sync","render","createRangeForCurrentPosition","startOffset","endOffset","i","getHopefulSize","averageItemSize","startElement","endElement","maxIndex","min","firstVisibleItemIndex","findFirstVisibleItemIndex","addedElements","documentFragment","createDocumentFragment","newElement","push","forEach","remove","measure","renderedElement","positionElement","scrollCorrection","offsetMismatch","maxScrollTop","checkRange","index","Object","keys","find","Number","item","String","calc","destroy","cancelAnimationFrame","value","main","JSON","parse","decodeURIComponent","location","search","slice","count","appElement","getElementById","assign","it","padding","innerHTML"],"mappings":"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","file":"src.529b3326.js","sourceRoot":"..","sourcesContent":["function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","export class Scrollbar {\n  /**\n   * @typedef {{totalSize: number, scrollListener: function(...[*]=), horizontal: boolean=, scrollTop: number=}} ScrollbarParams\n   */\n  /**\n   * @param {Element} viewportElement\n   * @param {ScrollbarParams} params\n   * @return {Scrollbar}\n   */\n  static builder(viewportElement, params) {\n    return new Scrollbar(viewportElement, params);\n  }\n\n  /**\n   * @param {Element} viewportElement\n   * @param {ScrollbarParams} params\n   */\n  constructor(viewportElement, params) {\n    /**\n     * @public\n     * @type number\n     */\n    this.scrollTop = 0;\n\n    /**\n     * @private\n     * @type Element\n     */\n    this.viewportElement = viewportElement;\n    /**\n     * @private\n     * @type Element\n     */\n    this.scrollElement = findScrollableElement(this.viewportElement);\n    /**\n     * @private\n     * @type Element\n     */\n    this.scrollListenElement = this.scrollElement === document.documentElement ? window : this.scrollElement;\n    /**\n     * @private\n     * @type function()\n     */\n    this.scrollListener = params.scrollListener;\n    /**\n     * @private\n     * @type boolean\n     */\n    this.horizontal = params.horizontal;\n    /**\n     * @public\n     * @type number\n     */\n    this.viewportSize = this.horizontal ? this.scrollElement.clientWidth : this.scrollElement.clientHeight;\n    /**\n     * Divide on 2 because it's too performance consuming and complicated handle case when offset between\n     * scroll node and viewport is changed dynamically we should also change max browser scroll size too.\n     * And Chrome works significantly slower and janky when you have a scrollbar with maximal height\n     * @private\n     * @type {number}\n     */\n    this.maxScrollSize = Math.round(calcMaxBrowserScrollSize(this.horizontal) / 2);\n\n    /**\n     * @private\n     * @type number\n     */\n    this.currentPage = 0;\n    /**\n     * @private\n     * @type number\n     */\n    this.prevViewportScrollTop = 0;\n\n    /**\n     * @private\n     * @type number\n     */\n    this.currentPageOffset = 0;\n\n    /**\n     * @private\n     * @type Element\n     */\n    this.runwayElement = document.createElement('div');\n    this.runwayElement.style[this.horizontal ? 'width' : 'height'] = this.scrollSize + 'px';\n    this.runwayElement.style.position = 'relative';\n    this.runwayElement.style.visibility = 'hidden';\n    this.runwayElement.style.overflow = 'hidden';\n    this.runwayElement.style.width = '1px';\n\n    this.updateTotalSize(params.totalSize || 0);\n\n    if (window.getComputedStyle(this.viewportElement).position === 'static') {\n      this.viewportElement.style.position = 'relative';\n    }\n\n    if (this.viewportElement.firstChild) {\n      this.viewportElement.insertBefore(this.runwayElement, this.viewportElement.firstChild);\n    } else {\n      this.viewportElement.appendChild(this.runwayElement);\n    }\n\n    this.addScrollListener();\n\n    if (params.scrollTop) {\n      this.scrollTo(params.scrollTop);\n    }\n  }\n\n  /**\n   * @private\n   */\n  onScroll() {\n    const viewportScrollTop = this.getViewportScrollTop();\n    if (Math.abs(viewportScrollTop - this.prevViewportScrollTop) > this.viewportSize) {\n      this.onJump();\n    } else {\n      this.onSmoothScroll();\n    }\n\n    this.prevViewportScrollTop = this.getViewportScrollTop();\n    this.updateScrollTop(this.getViewportScrollTop() + this.currentPageOffset);\n    this.scrollListener();\n  }\n\n  /**\n   * @private\n   * @param {number} scrollTop\n   */\n  updateScrollTop(scrollTop) {\n    this.scrollTop = Math.max(scrollTop, 0);\n  }\n\n  /**\n   * @private\n   * @return {number}\n   */\n  getViewportScrollTop() {\n    return Math.max(this.scrollElement.scrollTop - this.getOffsetBetweenScrollElementAndViewport(), 0);\n  }\n\n  /**\n   * @private\n   * @return {number}\n   */\n  getOffsetBetweenScrollElementAndViewport() {\n    return this.scrollElement !== this.viewportElement ? findOffsetBetween(this.viewportElement, this.scrollElement) : 0;\n  }\n\n  /**\n   * @private\n   * @param {number} viewportScrollTop\n   * @return {number}\n   */\n  viewportScrollTo(viewportScrollTop) {\n    const offset = this.getOffsetBetweenScrollElementAndViewport();\n    return this.scrollElement.scrollTop = viewportScrollTop + offset;\n  }\n\n  /**\n   * @private\n   */\n  onSmoothScroll() {\n    const scrollTop = this.getViewportScrollTop();\n\n    if (scrollTop + this.currentPageOffset > (this.currentPage + 1) * this.pageSize) {\n      this.scrollToNextPage();\n    } else if (this.currentPage && (scrollTop + this.currentPageOffset) < this.currentPage * this.pageSize) {\n      this.scrollToPrevPage();\n    }\n  }\n\n  /**\n   * @private\n   */\n  scrollToNextPage() {\n    this.scrollOnPage(this.currentPage + 1);\n  }\n\n  /**\n   * @private\n   */\n  scrollToPrevPage() {\n    this.scrollOnPage(this.currentPage - 1);\n  }\n\n  /**\n   * @private\n   */\n  onJump() {\n    const viewportScrollTop = this.getViewportScrollTop();\n    // convert actual pixels to total pixels\n    const scrollTop = viewportScrollTop * ((this.totalSize - this.viewportSize) / (this.scrollSize - this.viewportSize));\n    const pageNumber = Math.floor(scrollTop / this.pageSize);\n    this.setCurrentPage(pageNumber);\n  }\n\n  /**\n   * @private\n   * @param {number} currentPage\n   */\n  scrollOnPage(currentPage) {\n    const prevPage = this.currentPage;\n    if (prevPage < currentPage) {\n      this.viewportScrollTo(this.getViewportScrollTop() - this.overlapSize);\n    } else if (prevPage > currentPage) {\n      this.viewportScrollTo(this.getViewportScrollTop() + this.overlapSize);\n    }\n    this.setCurrentPage(currentPage);\n  }\n\n  /**\n   * @private\n   * @param {number} currentPage\n   */\n  setCurrentPage(currentPage) {\n    if (currentPage !== this.currentPage) {\n      this.currentPage = Math.max(currentPage, 0);\n      this.currentPageOffset = Math.round(this.currentPage * this.overlapSize);\n    }\n  }\n\n  /**\n   * @private\n   */\n  addScrollListener() {\n    /**\n     * @private\n     */\n    this.onScroll = this.onScroll.bind(this);\n    this.scrollListenElement.addEventListener('scroll', this.onScroll);\n  }\n\n  /**\n   * @private\n   */\n  removeScrollListener() {\n    this.scrollListenElement.removeEventListener('scroll', this.onScroll);\n  }\n\n  /**\n   * @public\n   * @param {number} totalSize\n   */\n  updateTotalSize(totalSize) {\n    if (this.totalSize === totalSize) {\n      return;\n    }\n\n    /**\n     * @public\n     * @type {number}\n     */\n    this.totalSize = totalSize;\n    /**\n     * @private\n     * @type {number}\n     */\n    this.scrollSize = this.maxScrollSize > this.totalSize ? this.totalSize : this.maxScrollSize;\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pageSize = Math.floor(this.maxScrollSize / 100);\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pageCount = Math.ceil(this.totalSize / this.pageSize);\n\n    const prevOverlapSize = this.overlapSize;\n    /**\n     * @private\n     * @type {number}\n     */\n    this.overlapSize = this.totalSize > this.maxScrollSize ? (this.totalSize - this.maxScrollSize) / (this.pageCount - 1) : 1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.currentPageOffset = Math.round(this.currentPage * this.overlapSize);\n\n    this.runwayElement.style[this.horizontal ? 'width' : 'height'] = this.scrollSize + 'px';\n\n    if (this.scrollTop > (this.totalSize - this.viewportSize)) {\n      this.updateScrollTop(this.totalSize - this.viewportSize);\n    }\n\n    // If we on the last page and user has updated totalSize\n    // we should check overlap size and if new overlap size is\n    // bigger than previous we should remove this difference by\n    // jumping back on this size otherwise it can lead to the problem\n    // that we have reach the bottom and can not scroll future but\n    // totalSize say that we should have scroll possibility\n    if (\n      this.currentPage === this.pageCount - 1 &&\n      prevOverlapSize &&\n      prevOverlapSize < this.overlapSize) {\n      this.prevViewportScrollTop = this.viewportScrollTo(this.prevViewportScrollTop - this.currentPage * (this.overlapSize - prevOverlapSize));\n    }\n  }\n\n  // noinspection JSUnusedGlobalSymbols\n  /**\n   * @public\n   * @param {number} scrollPosition\n   */\n  scrollTo(scrollPosition) {\n    if (this.scrollTop !== scrollPosition) {\n      this.updateScrollTop(scrollPosition);\n      const scrollPage = Math.floor(scrollPosition / this.pageSize);\n      this.setCurrentPage(scrollPage);\n      this.prevViewportScrollTop = this.viewportScrollTo(scrollPosition - this.currentPageOffset);\n    }\n  }\n\n  // noinspection JSUnusedGlobalSymbols\n  /**\n   * @public\n   * Calculate actual position on viewport for passed scrollbar position\n   * @param {number} position\n   * @return {number}\n   */\n  calc(position) {\n    return position - this.currentPageOffset;\n  }\n\n  // noinspection JSUnusedGlobalSymbols\n  /**\n   * @public\n   */\n  destroy() {\n    this.viewportElement.removeChild(this.runwayElement);\n    this.removeScrollListener();\n  }\n}\n\n/**\n * @param {boolean=} horizontal\n * @return {number}\n */\nexport function calcMaxBrowserScrollSize(horizontal) {\n  const bigNumber = '9999999999999999px';\n  const div = document.createElement('div');\n  const style = div.style;\n  style.position = 'absolute';\n  style.left = bigNumber;\n  style.top = bigNumber;\n  document.body.appendChild(div);\n\n  const size = div.getBoundingClientRect()[horizontal ? 'left' : 'top'] || parseInt(bigNumber);\n  document.body.removeChild(div);\n  return Math.abs(size);\n}\n\n/**\n * @param {Element|Node} element\n * @return {Element}\n */\nexport function findScrollableElement(element) {\n  while (element.parentNode && element.parentNode !== document) {\n    const overflow = window.getComputedStyle(element).overflow;\n    if (overflow === 'visible' || overflow === '') {\n      element = element.parentNode;\n      continue;\n    }\n    break;\n  }\n  return element;\n}\n\n/**\n * @param {(Element|HTMLElement|Node)} element\n * @param {(Element|HTMLElement|Node)} scrollElement\n * @return {number}\n */\nfunction findOffsetBetween(element, scrollElement) {\n  // If scrollElement is documentElement we can\n  // calculate it by getBoundingClientRect and dont traverse all parents\n  if (scrollElement === document.documentElement) {\n    return element.getBoundingClientRect().top - scrollElement.getBoundingClientRect().top;\n  }\n\n  let offset = 0;\n  while (element && element.parentNode && element !== scrollElement) {\n    // noinspection JSValidateTypes\n    /**\n     * @type {HTMLElement}\n     */\n    const parentNode = element.parentNode;\n    offset = (window.getComputedStyle(parentNode).position !== 'static') ?\n      offset + (element.offsetTop) :\n      offset + (element.offsetTop - parentNode.offsetTop);\n    element = parentNode;\n  }\n  return offset;\n}","const DEFAULT_HEIGHT_ESTIMATE_PX = 50;\n\nexport class SizeManager {\n  /**\n   * @returns {SizeManager}\n   */\n  static builder() {\n    return new SizeManager();\n  }\n\n  constructor() {\n    this.reset();\n  }\n\n  /**\n   * @param {!HTMLElement} element The element to measure.\n   * @return {boolean}\n   */\n  has(element) {\n    return this.sizes.has(element);\n  }\n\n  /**\n   * Measures and stores |element|'s size. If |element| was measured\n   * previously, this updates everything to use the new current size.\n   * @param {!HTMLElement} element The element to measure.\n   */\n  measure(element) {\n    let oldSize = this.sizes.get(element);\n    if (oldSize === undefined) {\n      oldSize = 0;\n      this.measuredCount++;\n    }\n    const newSize = element.offsetHeight;\n    this.totalMeasuredSize += newSize - oldSize;\n    this.sizes.set(element, newSize);\n  }\n\n  /**\n   * Returns a size for |element|, either the last stored size or an\n   * estimate based on all other previously measured elements or a\n   * default.\n   * @param {!HTMLElement} element The element to produce a size for.\n   * @return {number}\n   */\n  getHopefulSize(element) {\n    const size = this.sizes.get(element);\n    return size === undefined ? this.getAverageSize() : size;\n  }\n\n  getAverageSize() {\n    return this.measuredCount > 0 ?\n      this.totalMeasuredSize / this.measuredCount :\n      DEFAULT_HEIGHT_ESTIMATE_PX;\n  }\n\n  /**\n   * Removes all data related to |element| from the manager.\n   * @param {!HTMLElement} element The element to remove.\n   */\n  remove(element) {\n    const oldSize = this.sizes.get(element);\n    if (oldSize === undefined) {\n      return;\n    }\n    this.totalMeasuredSize -= oldSize;\n    this.measuredCount--;\n    this.sizes.delete(element);\n  }\n\n  reset() {\n    this.sizes = new WeakMap();\n    this.totalMeasuredSize = 0;\n    this.measuredCount = 0;\n  }\n}\n","/**\n * @param {HTMLElement} element\n * @param {function} listener\n * @return {function(...[*]=)} Remove listener function\n */\nexport function addResizeListener(element, listener) {\n  const options = {passive: true, capture: true};\n  const resizeObserver = createResizeObserver();\n\n  if (element.style.position === 'static') {\n    element.style.position = 'relative';\n  }\n\n  element.appendChild(resizeObserver);\n  resizeObserver.addEventListener('scroll', onScroll, options);\n\n  // Postpone calculation to avoid \"Layout Thrashing\"\n  queueMicrotask(() => setupTriggers(resizeObserver));\n\n  return () => {\n    resizeObserver.removeEventListener('scroll', onScroll, options);\n    element.removeChild(resizeObserver);\n  };\n\n  function onScroll(event) {\n    if (\n      onScroll.prevElementHeight !== element.offsetHeight ||\n      onScroll.prevElementWidth !== element.offsetWidth) {\n      onScroll.prevElementHeight = element.offsetHeight;\n      onScroll.prevElementWidth = element.offsetWidth;\n      const resizeObserver = event.currentTarget;\n      setupTriggers(resizeObserver);\n      listener(element);\n    }\n  }\n}\n\n/**\n * @param {Node} resizeObserver\n */\nfunction setupTriggers(resizeObserver) {\n  const growObserver = resizeObserver.firstChild;\n  const shrinkObserver = resizeObserver.lastChild;\n  const growObserverOffsetHeight = growObserver.offsetHeight;\n  const growObserverOffsetWidth = growObserver.offsetWidth;\n  const growObserverScrollHeight = growObserver.scrollHeight;\n  const growObserverScrollWidth = growObserver.scrollWidth;\n  const shrinkObserverScrollHeight = shrinkObserver.scrollHeight;\n  const shrinkObserverScrollWidth = shrinkObserver.scrollWidth;\n\n  queueMicrotask(() => {\n    growObserver.firstChild.style.height = growObserverOffsetHeight + 1 + 'px';\n    growObserver.firstChild.style.width = growObserverOffsetWidth + 1 + 'px';\n    queueMicrotask(setupScrollPosition);\n  });\n\n  function setupScrollPosition() {\n    growObserver.scrollTop = growObserverScrollHeight;\n    growObserver.scrollLeft = growObserverScrollWidth;\n    shrinkObserver.scrollTop = shrinkObserverScrollHeight;\n    shrinkObserver.scrollLeft = shrinkObserverScrollWidth;\n  }\n}\n\n/**\n * @return {Node}\n */\nfunction createResizeObserver() {\n  if (!createResizeObserver.resizeObserver) {\n    const resizeObserver = document.createElement('div');\n    const growObserver = document.createElement('div');\n    const shrinkObserver = document.createElement('div');\n    const style = 'position: absolute; height: 100%; width: 100%; top:0; left:0; opacity: 0; visibility: hidden; z-index: -1; overflow: hidden; contain: paint size style; pointer-events: none;';\n\n    resizeObserver.setAttribute('style', style);\n    growObserver.setAttribute('style', style);\n    shrinkObserver.setAttribute('style', style);\n    growObserver.style.overflow = shrinkObserver.style.overflow = 'auto';\n    growObserver.appendChild(document.createElement('div'));\n    shrinkObserver.appendChild(document.createElement('div'));\n    resizeObserver.appendChild(growObserver);\n    resizeObserver.appendChild(shrinkObserver);\n    shrinkObserver.firstChild.style.height = '200%';\n    shrinkObserver.firstChild.style.width = '200%';\n\n    createResizeObserver.resizeObserver = resizeObserver;\n  }\n\n  return createResizeObserver.resizeObserver.cloneNode(true);\n}\n\nif (typeof window.queueMicrotask !== 'function') {\n  window.queueMicrotask = function(callback) {\n    Promise.resolve()\n      .then(callback)\n      .catch(e => setTimeout(() => { throw e; }));\n  };\n}\n","import { Scrollbar } from './scrollbar';\nimport { SizeManager } from './size-manager';\nimport { addResizeListener } from './resize-observer';\n\nexport class VirtualScroller {\n  /**\n   * @typedef {{itemCount: number, itemBuilder: function(number):Element, onRemoveItem: function(number)=, itemSize: number=, bufferSize: number=, scrollTop: number=}} VirtualScrollerParams\n   */\n  /**\n   * @param {Element} element\n   * @param {VirtualScrollerParams} params\n   * @returns {VirtualScroller}\n   */\n  static builder(element, params) {\n    return new VirtualScroller(element, params);\n  }\n\n  /**\n   * @param {Element} viewportElement\n   * @param {VirtualScrollerParams} params\n   */\n  constructor(viewportElement, params) {\n    /**\n     * @private\n     * @type {Element}\n     */\n    this.viewportElement = viewportElement;\n    /**\n     * @private\n     * @type {number}\n     */\n    this.itemCount = params.itemCount;\n    /**\n     * @private\n     * @type {function(number)}\n     */\n    this.onRemoveItem = params.onRemoveItem;\n    /**\n     * @private\n     * @type {function(number):Element}\n     */\n    this.itemBuilder = params.itemBuilder;\n    /**\n     * @private\n     * @type {number}\n     */\n    this.bufferSize = params.hasOwnProperty('bufferSize') ? params.bufferSize : 1;\n    /**\n     * @private\n     * @type {SizeManager}\n     */\n    this.sizeManager = SizeManager.builder();\n    /**\n     * @private\n     * @type {number}\n     */\n    this.expectedItemSize = params.itemSize || this.sizeManager.getAverageSize();\n    /**\n     * @private\n     * @type {number}\n     */\n    this.expectedTotalSize = this.itemCount * this.expectedItemSize;\n    /**\n     * @private\n     * @type {{}}\n     */\n    this.rendered = {};\n    /**\n     * @private\n     * @type {{start: number, end: number}}\n     */\n    this.range = {start: 0, end: 0};\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.prevScrollTop = params.scrollTop || 0;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.throttleTime = 50;\n\n    /**\n     * @private\n     * @type {Scrollbar}\n     */\n    this.scrollbar = Scrollbar.builder(this.viewportElement, {\n      scrollTop: this.prevScrollTop,\n      totalSize: this.expectedTotalSize,\n      scrollListener: () => this.onScroll()\n    });\n    this.scheduleSync();\n  }\n\n  /**\n   * @private\n   */\n  onScroll() {\n    const scrollTop = this.scrollTop();\n    window.clearTimeout(this.scrollThrottlingId);\n    if (Math.abs(scrollTop - this.prevScrollTop) > this.scrollbar.viewportSize) {\n      // Throttle rendering and layout if user scroll too fast to improve scroll performance\n      // We can stuck with this case when use scrollbar holder to change position\n      this.scrollThrottlingId = setTimeout(() => {\n        this.scheduleSync();\n      }, this.throttleTime);\n    } else {\n      this.scheduleSync();\n    }\n    this.prevScrollTop = scrollTop;\n  }\n\n  /**\n   * @private\n   */\n  scheduleSync() {\n    this.syncId = this.syncId || window.requestAnimationFrame(() => {\n      this.syncId = null;\n      this.sync();\n    });\n  }\n\n  /**\n   * @private\n   */\n  sync() {\n    this.render(this.createRangeForCurrentPosition());\n  }\n\n  /**\n   * @private\n   * @returns {{start: number, end: number}}\n   */\n  createRangeForCurrentPosition() {\n    const scrollTop = this.scrollTop();\n    const viewportSize = this.scrollbar.viewportSize;\n    const bufferSize = this.bufferSize * viewportSize;\n    const startOffset = Math.max(scrollTop - bufferSize, 0);\n    const endOffset = scrollTop + viewportSize + bufferSize;\n\n    let start = Math.floor(startOffset / this.expectedItemSize);\n    for (let i = this.range.start; i <= this.range.end; i++) {\n      if (this.rendered[i] && this.rendered[i].offset + this.sizeManager.getHopefulSize(this.rendered[i]) > startOffset) {\n        start = i;\n        break;\n      }\n    }\n\n    let end = Math.ceil(endOffset / this.expectedItemSize) - 1;\n    for (let i = this.range.end; i >= this.range.start; i--) {\n      if (this.rendered[i] && this.rendered[i].offset < endOffset && this.rendered[i].offset >= startOffset) {\n        end = i;\n        break;\n      }\n    }\n\n    // Use average item size to more precisely calculate how many items we should render\n    // if expected item size failed and we have rendered items\n    const averageItemSize = this.sizeManager.getAverageSize();\n    const startElement = this.rendered[start];\n    if (startElement && startElement.offset > startOffset) {\n      start = start - Math.ceil((startElement.offset - startOffset) / averageItemSize);\n    }\n\n    const endElement = this.rendered[end];\n    if (endElement && (endElement.offset + this.sizeManager.getHopefulSize(endElement)) < endOffset) {\n      end = end + Math.ceil((endOffset - (endElement.offset + this.sizeManager.getHopefulSize(endElement))) / averageItemSize);\n    }\n\n    const maxIndex = this.itemCount - 1;\n    return {\n      start: Math.min(Math.max(start, 0), maxIndex),\n      end: Math.max(Math.min(end, maxIndex), 0)\n    };\n  }\n\n  /**\n   * @private\n   * @param {{start: number, end: number}} range\n   */\n  render(range) {\n    const firstVisibleItemIndex = this.findFirstVisibleItemIndex();\n    const addedElements = [];\n    let documentFragment = document.createDocumentFragment();\n    for (let i = range.start; i <= range.end; i++) {\n      /**\n       * Render elements so that preserving correct position in DOM tree\n       * so elements with less index should go in the DOM first\n       */\n      if (!this.rendered[i]) {\n        const newElement = this.rendered[i] = this.createElement(i);\n        addedElements.push(newElement);\n        documentFragment.appendChild(newElement);\n      } else if (documentFragment.firstChild) {\n        this.viewportElement.insertBefore(documentFragment, this.rendered[i]);\n        documentFragment = document.createDocumentFragment();\n      }\n    }\n    this.viewportElement.appendChild(documentFragment);\n\n    addedElements.forEach((element) => {\n      addResizeListener(element, () => {\n        this.sizeManager.remove(element);\n        this.scheduleSync();\n      });\n    });\n\n    /**\n     * Remove elements which out of the range\n     */\n    for (let i = this.range.start; i <= this.range.end; i++) {\n      if ((i < range.start || i > range.end) && this.rendered[i]) {\n        this.onRemoveItem && this.onRemoveItem(i);\n        this.sizeManager.remove(this.rendered[i]);\n        this.viewportElement.removeChild(this.rendered[i]);\n        delete this.rendered[i];\n      }\n    }\n\n    // Measure rendered elements sizes\n    for (let i = range.start; i <= range.end; i++) {\n      if (!this.sizeManager.has(this.rendered[i])) {\n        this.sizeManager.measure(this.rendered[i]);\n      }\n    }\n\n    // Layout elements\n    /**\n     * If we already have rendered elements we should try to position new\n     * elements or re-layout previous after resize with offset related to previously rendered elements\n     * this allows us to cover most popular case when user scroll from top to bottom and\n     * back. But if user would start from some middle point we can end with some jumping\n     * when reach the point where offset is negative\n     */\n    if (this.rendered[firstVisibleItemIndex] && range.start < firstVisibleItemIndex) {\n      let offset = this.rendered[firstVisibleItemIndex].offset;\n      for (let i = (firstVisibleItemIndex - 1); i >= range.start; i--) {\n        const renderedElement = this.rendered[i];\n        offset = offset - this.sizeManager.getHopefulSize(renderedElement);\n        this.positionElement(renderedElement, Math.max(offset, 0));\n      }\n    }\n\n    // If we reach the first element and its offset bigger than 0\n    // we should reset offset and correct scroll position\n    // We can stuck with this case when user had narrow viewport\n    // then scroll down so that we have removed this first element\n    // and then make viewport bigger so because we don't correct\n    // position on resize we should correct it here\n    if (range.start === 0 && this.rendered[0].offset > 0) {\n      this.rendered[0].offset = 0;\n    }\n\n    /**\n     * If start element already positioned we should start from\n     * this point otherwise calculate estimated offset\n     */\n    let scrollCorrection = 0;\n    let startElement = this.rendered[range.start];\n    let offset = startElement && startElement.offset ? startElement.offset : range.start * this.expectedItemSize;\n    for (let i = range.start; i <= range.end; i++) {\n      const renderedElement = this.rendered[i];\n      if (i === firstVisibleItemIndex) {\n        scrollCorrection = offset - renderedElement.offset;\n      }\n      this.positionElement(renderedElement, offset);\n      offset += this.sizeManager.getHopefulSize(renderedElement);\n    }\n\n    if (scrollCorrection) {\n      this.scrollTo(this.scrollTop() + scrollCorrection);\n    }\n\n    /**\n     * Adjust scrollbar size\n     */\n    const offsetMismatch = offset - (range.end * this.expectedItemSize);\n    const maxScrollTop = this.scrollbar.totalSize - this.scrollbar.viewportSize;\n    const maxIndex = this.itemCount - 1;\n    if (this.scrollTop() >= maxScrollTop &&\n      (offset > this.scrollbar.totalSize || range.end < maxIndex)) {\n      // Increase scroll height if we reach end but we still have items which\n      // should be rendered\n      this.scrollbar.updateTotalSize(this.expectedTotalSize + offsetMismatch);\n    } else if (range.end === maxIndex) {\n      // If this is the last element we should correct scroll height\n      // because we can render more space then we need\n      this.scrollbar.updateTotalSize(offset);\n    }\n\n    this.range = range;\n\n    const checkRange = this.createRangeForCurrentPosition();\n    if (checkRange.start !== range.start || checkRange.end !== range.end) {\n      this.scheduleSync();\n    }\n  }\n\n  /**\n   * Return first visible item index\n   * @return {number} Returns -1 if we can not find first visible item\n   */\n  findFirstVisibleItemIndex() {\n    const scrollTop = this.scrollTop();\n    const index = Object.keys(this.rendered).find((i) => {\n      const renderedElement = this.rendered[i];\n      return renderedElement.offset <= scrollTop && renderedElement.offset + this.sizeManager.getHopefulSize(renderedElement) > scrollTop;\n    });\n    return index ? Number(index) : -1;\n  }\n\n  /**\n   * @private\n   * @param {number} i Element index\n   * @returns {HTMLElement}\n   */\n  createElement(i) {\n    const item = document.createElement('div');\n    item.setAttribute('index', String(i));\n    item.style.position = 'absolute';\n    item.style.width = '100%';\n    item.appendChild(this.itemBuilder(i));\n    return item;\n  }\n\n  /**\n   * @private\n   * @param {HTMLElement} renderedElement\n   * @param {number} offset\n   */\n  positionElement(renderedElement, offset) {\n    renderedElement.style.top = this.scrollbar.calc(offset) + 'px';\n    renderedElement.offset = offset;\n  }\n\n  /**\n   * @public\n   * @return {number}\n   */\n  scrollTop() {\n    return this.scrollbar.scrollTop;\n  }\n\n  /**\n   * @public\n   * @param {number} position\n   */\n  scrollTo(position) {\n    this.scrollbar.scrollTo(position);\n  }\n\n  /**\n   * @public\n   */\n  destroy() {\n    this.scrollbar.destroy();\n    this.sizeManager = null;\n    this.rendered = null;\n    window.cancelAnimationFrame(this.syncId);\n    window.clearTimeout(this.scrollThrottlingId);\n    this.syncId = null;\n    this.scrollThrottlingId = null;\n  }\n\n  /**\n   * @public\n   * @param {number} value\n   */\n  updateItemCount(value) {\n    if (this.itemCount !== value) {\n      this.itemCount = value;\n      this.expectedTotalSize = this.itemCount * this.expectedItemSize;\n      this.scrollbar.updateTotalSize(this.expectedTotalSize);\n      this.scheduleSync();\n    }\n  }\n}\n","import { VirtualScroller } from '../lib/virtual-scroller';\n\nfunction main() {\n  const params = JSON.parse(decodeURIComponent(window.location.search.slice(1)) || '{}');\n  const count = params.itemCount || 3000000;\n\n  const appElement = document.getElementById('app');\n\n  if (!params.window) {\n    appElement.style.height = '80vh';\n    appElement.style.overflow = 'auto';\n  }\n\n  VirtualScroller.builder(appElement, Object.assign({\n    itemCount: count,\n    itemBuilder(it) {\n      const item = document.createElement('div');\n      item.style.padding = '8px';\n      item.innerHTML = it % 2 ?\n        `<b>${it + 1}</b>/${count} - Lorem Ipsum is simply dummy text` :\n        `<b>${it + 1}</b>/${count} - Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book`;\n      return item;\n    }\n  }, params));\n}\n\nmain();\n"]}